---
title: '线程安全'
---

### 线程安全的定义
- 多线程访问时，采用了加锁的机制，当一个线程操作该类的某个数据时，进行保护，其他线程不能进行访问直到该线程操作完，其他线程才可以使用。不会出现数据不一致或数据污染。
### 死锁，场景，如何解决
- 死锁是指当多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进行都将无法向前推进。
- 死锁产生的原因：
    - 系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。
    - 进程运行推进顺寻不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。
- 死锁的必要条件：
    - 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占用。此时若有其他进程请求该资源，则请求进程只能等待。
    - 请求保持条件：进行已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进行被阻塞，但对自己已获得的资源保持不放。
    - 不可剥夺条件：进行所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。
    - 循环等待条件：若干进程间形成首尾相接循环等待资源的关系。
- 死锁的排查：
    - 当出现死锁的时候，一般情况下会出现响应超时等现象。如果JVM出现死锁，可以通过jstack命令打印出栈信息，一般如果存在死锁可以在打印出的信息中看到Dead Lock字样。再通过发生死锁的线程id查看现场栈，即可定位到发生死锁的代码。
    - 当数据库出现死锁时，数据库会阻止执行线程继续死锁，中断执行，并向客户端抛出死锁的错误信息，分析时，可以通过分析数据库binlog，查看抛出死锁错误的时候，是哪个sql导致出现的死锁。在Mysql InnoDB引擎中，使用的是行级锁，行级锁不锁记录，锁索引。如果一条SQL用到了主键索引，mysql会锁住主键索引，如果用到了非主键索引，mysql会先所锁住非主键索引，再锁住主键索引。当一条SQL通过非主键索引更新，另一条SQL通过主键更新非主键索引字段就可能会造成死锁。

### Java中如何给对象加锁
 - 通过synchronized关键字加锁，一般用在方法上或同步代码块，加在静态方法上时，锁定的时类对象，加载非静态方法上，锁定的是调用该方法的对象。不需要手动释放锁，由JVM控制。JVM对synchronized进行了优化，加锁效果提升很多。当没有其他线程抢占资源时，加的锁是偏向锁，同一个线程访问，不需要尝试获取锁，效率最高。一旦出现了其他线程尝试抢占资源，锁就会升级为轻量级锁。如果没有获取到锁，会进行一定次数的自旋，也许马上就能获取到锁，避免线程切换。但当自旋一定次数后，仍获取不到锁，就会升级为重量级锁。
    - 通过ReentrankLock加锁，需要手动加锁，手动释放，一般会把释放锁放到finally中，避免出现异常导致锁不会被释放
- 偏向锁：无锁竞争的情况下为了减少锁竞争的资源开销，引入偏向锁。
    - 优点：加锁和解锁不需要额外的小号，和执行非同步方法相比仅存在纳秒级的差距
    - 缺点：如果线程间存在锁竞争，会带来额外的锁撤销的消耗
    - 适用场景：适用于只有一个线程访问同步块场景
- 轻量级锁：轻量级锁适用于线程交替执行同步块的情况。
    - 优点：竞争的线程不会阻塞，提高了程序的响应速度。
    - 缺点：如果始终得不到锁竞争的线程，使用自旋会消耗CPU
    - 适用场景：追求响应时间、同步块执行速度非常快
- 重量级锁：
    - 优点：线程竞争不适用自旋，不会消耗CPU
    - 缺点：线程阻塞，响应时间缓慢
    - 适用场景：追求吞吐量，同步块执行速度较长
- 锁粗化：减少不必要的紧连在一起的unlock、lock操作，将多个连续的锁扩展成一个范围更大的锁。
- 锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。
- 适应性自旋：自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过的锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。另一方面，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。

### Java加锁的原理
- synchronized基于Monitor实现同步

    - Java使用对象锁（使用synchronized获得对象锁）保证工作在共享的数据集上的线程互斥执行。
    - 使用notify/notifyAll/wait方法来协同不同线程之间的工作。
    - Class和Object都关联了一个Monitor
    - Monitor工作原理
        - 线程进入同步方法中
        - 为了继续执行临界区代码，线程必须获取Monitor锁，如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程。
        - 拥有监视者对象的线程可以调用wait()进入等待集合，同时释放监视锁，进入等待状态
        - 其他线程调用notify()/notifyAll()接口唤醒等待集合中的线程，这些等待的线程需要重新获取监视锁后才能啊hi行wait()之后的代码。
        - 同步方法执行完毕了，线程退出临界区，并释放监视锁
    
    - 锁标记存放在Java对象头的Mark Word中

- CAS：CompareAndSet,CompareAndSwap，比较并交换，是一个原子操作， 它比较一个内存位置的值并且只有相等时修改这个内存位置的值为新的值，保证了新的值总是基于最新的信息计算的，如果由其他线程在这期间修改了这个值则CAS失败。CAS返回是否成功或者内存位置原来的值用于判断是否CAS成功。
    - 优点：竞争不大的时候系统开销小。
    - 缺点：1、循环时间长开销大。CAS长时间自旋不成功，给CPU带来很大的性能开销。解决办法：JVM能支持pause指令，效率会有一定的提升。2、只能保证一个共享变量的原子操作。对多个共享变量操作时，不能保证原子性。解决办法：加锁；共享变量合并成一个共享变量。3、ABA问题：解决办法是增加版本号，每次适用的时候版本号+1，每次变量更新的时候版本号+1。Java提供AtomicStampedReference来解决ABA问题。
- AQS：队列同步器，用来构建锁或者其他同步组件的基础框架。
    - 使用一个int成员变量表示同步状态
    - 通过内置的FIFO双向队列来完成获取锁线程的排队工作。
        - 同步器包含两个节点类型的应用，一个指向头节点，一个指向尾节点，未获取到锁的线程会创建节点线程安全的加入队列尾部。同步队列遵循FIFO，首节点是获取同步状态成功的节点。
        - 未获取到锁的线程将创建一个节点，设置到尾节点。
        - 首节点的线程在释放锁时，将会唤醒后继节点，后继节点将会在获取锁成功时将自己设置为首节点
    - 独占式/共享式锁获取
        - 独占式：有且只有一个线程能获取到锁，如：ReentrantLock。每个节点自旋观察自己的前一节点是不是Header节点，如果是，就去尝试获取锁。
        - 共享式：可以多个线程同时获取到锁，如：CountDownLatch

### 自旋锁、阻塞锁、重入锁的基本原理
- 重入锁：也叫递归锁，指的是同一线程在外层函数获得锁之后，内层递归函数仍然有获取锁的代码，但不受影响，

### 常用的原子类