---
title: '线程安全'
---

### 线程安全的定义
- 多线程访问时，采用了加锁的机制，当一个线程操作该类的某个数据时，进行保护，其他线程不能进行访问直到该线程操作完，其他线程才可以使用。不会出现数据不一致或数据污染。
### 死锁，场景，如何解决
- 死锁是指当多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进行都将无法向前推进。
- 死锁产生的原因：
    - 系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。
    - 进程运行推进顺寻不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。
- 死锁的必要条件：
    - 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占用。此时若有其他进程请求该资源，则请求进程只能等待。
    - 请求保持条件：进行已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进行被阻塞，但对自己已获得的资源保持不放。
    - 不可剥夺条件：进行所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。
    - 循环等待条件：若干进程间形成首尾相接循环等待资源的关系。
- 死锁的排查：
    - 当出现死锁的时候，一般情况下会出现响应超时等现象。如果JVM出现死锁，可以通过jstack命令打印出栈信息，一般如果存在死锁可以在打印出的信息中看到Dead Lock字样。再通过发生死锁的线程id查看现场栈，即可定位到发生死锁的代码。
    - 当数据库出现死锁时，数据库会阻止执行线程继续死锁，中断执行，并向客户端抛出死锁的错误信息，分析时，可以通过分析数据库binlog，查看抛出死锁错误的时候，是哪个sql导致出现的死锁。在Mysql InnoDB引擎中，使用的是行级锁，行级锁不锁记录，锁索引。如果一条SQL用到了主键索引，mysql会锁住主键索引，如果用到了非主键索引，mysql会先所锁住非主键索引，再锁住主键索引。当一条SQL通过非主键索引更新，另一条SQL通过主键更新非主键索引字段就可能会造成死锁。

### Java中如何给对象加锁
- 通过synchronized关键字加锁，一般用在方法上或同步代码块，加在静态方法上时，锁定的时类对象，加载非静态方法上，锁定的是调用该方法的对象。不需要手动释放锁，由JVM控制。JVM对synchronized进行了优化，加锁效果提升很多。当没有其他线程抢占资源时，加的锁是偏向锁，同一个线程访问，不需要尝试获取锁，效率最高。一旦出现了其他线程尝试抢占资源，锁就会升级为轻量级锁。如果没有获取到锁，会进行一定次数的自旋，也许马上就能获取到锁，避免线程切换。但当自旋一定次数后，仍获取不到锁，就会升级为重量级锁。
- 通过ReentrankLock加锁，需要手动加锁，手动释放，一般会把释放锁放到finally中，避免出现异常导致锁不会被释放

## Java加锁的原理

## 自旋锁、阻塞锁、重入锁的基本原理

## 常用的原子类